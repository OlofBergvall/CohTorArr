# ***********************************************************************************************
#
#
# Functions for convenience
#
#
# ***********************************************************************************************

# Takes a root system R and returns the a set of representatives for the
# conjugacy classes of the corresponding Weyl group.
def classreps(R):
    G=R.ambient_space().weyl_group()
    return G.conjugacy_classes_representatives()

# ***********************************************************************************************
#
# Functions for generating the set of modules.
#
# ***********************************************************************************************

# Checks if u=+/-v.    
def pmeq(u,v):
    if u == v:
        return True
    elif u == -v:
        return True
    else:
        return False 

# Takes a root system R and returns a module representing the root system.
def givemodule(R):
    A=R.ambient_space()
    SR=A.simple_roots()
    vecs=[]
    for i in range(len(SR)):
        v=vector(SR[i+1])
        vecs.append(v)
    Vamb=ZZ**len(A.basis())
    V=Vamb.span(vecs)
    return V

# Returns the roots of the root system R as vectors.
def vecroots(R):
    A=R.ambient_space()
    PR=A.roots()
    out=[]
    for i in range(len(PR)):
        v=vector(PR[i])
        out.append(v)
    return out
  
# Takes a group element g of W(R) (in matrix form) and a
# set of roots vR (a list of vectors) and returns the orbits of
# vR under the action of g (more precisely, the cyclic group 
# generated by g) as a list of lists.
def orbs(g,vR):
    out=[]
    S=vR[:]
    while len(S)>0:
        s=g*S[0]
        orb=[S[0],-S[0]]
        while pmeq(S[0],s)==False:
            orb.append(s)
            orb.append(-s)
            S.remove(s)
            S.remove(-s)
            s=g*s
        out.append(orb)
        S.remove(-S[0])
        S.remove(S[0])
    return out

# Takes an element g of the Weyl group (in matrix form) and
# the root system R and returns a set of the maximal proper 
# g-stable submodules of  the module corresponding to the 
# root system.
def stabsubmods(g,R):
    out=[]
    M=givemodule(R)
    vR=vecroots(R)
    orb=orbs(g,vR)
    for i in range(len(orb)):
        V=M.span(orb[i],ZZ)
        out.append(V)
    return Set(out)
