#Functions for computing the cohomology of the complement of the toric arrangement associated to a root system R when the root system is given
#inside the ambient space of some bigger root system R'. It is assumed that the ambient space is known, that the Weyl group of R has
#been determined in the Weyl group of R' and that at least one (simple) root of R has been found. The computations can be done with 
#coefficients in the ring of Eisenstein integers or in the integers.

# Checks if u=+/-v.
def pmeq(u,v):
    if u == v:
        return True
    elif u == -v:
        return True
    else:
        return False

#Takes a simple root s, a Weyl group W and generates the roots.
def give_roots(s,W):
    R = []
    for w in W:
        r = w*vector(s)
        if r not in R:
            R.append(r)
    return R

#Takes a set of roots R, an ambient space A containing R and generates the Z-module generated by R.
def givemodule(R,A):
    vecs=[]
    for r in R:
        v=vector(r)
        vecs.append(v)
    Vamb=ZZ**len(A.basis())
    V=Vamb.span(vecs)
    return V

# Takes a group element g (in matrix form) and a set of roots vR (a list of vectors) and returns the orbits of vR under the action of 
# g (more precisely, the cyclic group generated by g) as a list of lists.
def orbs(g,vR):
    out=[]
    S=vR[:]
    while len(S)>0:
        s=g*S[0]
        orb=[S[0],-S[0]]
        while pmeq(S[0],s)==False:
            orb.append(s)
            orb.append(-s)
            S.remove(s)
            S.remove(-s)
            s=g*s
        out.append(orb)
        S.remove(-S[0])
        S.remove(S[0])
    return out

#Takes a group element g, a set of roots R and an ambient space containing the roots A and returns a set of the maximal proper 
# g-stable submodules of  the module corresponding to the root system generated by s and W.
def stabsubmods(g,R,A):
    out =[]
    M = givemodule(R,A)
    orb = orbs(g,R)
    for i in range(len(orb)):
        V=M.span(orb[i],ZZ)
        out.append(V)
    return Set(out)

# ---------------------------------------------------------------------------------
#
# Code for generating the set,
#
# ---------------------------------------------------------------------------------

# Converts the input of newmodules to something passable to parnewmodules.
def argtopar(S1, S2, S3):
    arg = []
    for s in S1:
        arg.append((s, S2, S3))
    return arg

# Takes a module M (from the initial set of modules) and a set of previously generated modules (prev) and a total set of modules (old)
# and generates all sums of a module in prev and startM.
@parallel(sage.parallel.ncpus.ncpus())
def parnewmodules(M, prev, old):
    out = []
    for P in prev:
        temp = M + P
        if temp not in old:
            temp = temp.echelonized_basis_matrix()
            temp.set_immutable()
            out.append(
                temp)  # Apparantly we cannot parallelize using the type module as output, hence the weird conversion.
    return Set(out).list()

# Converts the output of parnewmodules to a set of modules.
def tomodlist(gen, pgend):
    out = []
    for G in gen:
        for g in G[1]:
            # if isinstance(g,basestring):
            #    print(g)
            out.append(span(g, ZZ))
    return pgend.union(Set(out))


# Splits a list L into a bunch of lists with n elements. Since not all lists have a length divisible by L, the final list may be 
# shorter than len(L)/n.
def split_list(L, n):
    l = (len(L) / n).floor()
    r = len(L) - n * l
    out = []
    for i in range(0, l):
        out.append(Set([L[j] for j in range(i * n, (i + 1) * n)]))
    if r > 0:
        out.append(Set([L[j] for j in range(l * n, l * n + r)]))
    return out


# Takes a module an initial set of modules (start), a set of previously generated modules (prev) and a total set of modules (old)
# and generates all sums of a module in "prev" and a module in "start" which do not occur in "old".
def newmodules_par(start, prev, old):
    ncpus = Integer(sage.parallel.ncpus.ncpus())
    lists = split_list(start, ncpus)
    nmds = Set([])
    i = 1
    for l in lists:
        i = i + 1
        arg = argtopar(l, prev, old)
        gen = parnewmodules(arg)
        nmds = tomodlist(gen, nmds)
    return nmds


# Takes a set of previously (prev) generated modules, an initial set of modules (start) and an total set of modules (old) and
# generates the next set of modules.
def newmodules(start, prev, old):
    out = Set([])
    for i in range(len(start)):
        for j in range(len(prev)):
            n = i * len(prev) + j
            temp = start[i] + prev[j]
            if temp not in old:
                out = out.union(Set([temp]))
    return out


# Generates the set of g-stable submodules without poset structure.
def setofmodules(startlist):  # , Integer n):
    t0 = walltime()
    tcurr = walltime()
    start = startlist
    old = startlist
    prev = startlist
    ct = 1
    while len(prev) > 0:
        print(str(len(prev)) + " sums of " + str(ct) + " modules were generated in " + str(walltime() - tcurr) + " seconds.")
        tcurr = walltime()
        prev = newmodules_par(start, prev, old)
        old = old + prev
        ct = ct + 1
    n = old[0].degree()
    zv = vector([0] * n)
    ZM = old[0].span(zv)
    old = [ZM] + old.list()
    print("A set containing " + str(len(old)) + " elements was generated in " + str(walltime() - t0) + " seconds.")
    return old

# ---------------------------------------------------------------------------------------
#
#  Code for generating the poset structure.
#
# ---------------------------------------------------------------------------------------

# Converts the input of gen_rels to something passable to par_gen_rels.
def argtopar_gen_rels(L, S):
    arg = []
    for l in L:
        arg.append((l, S))
    return arg

@parallel(sage.parallel.ncpus.ncpus())
def par_gen_rels(M, S):
    m = matrix(1, len(S), sparse=True)
    # m=[0 for s in S]
    for i in range(len(S)):
        if M.is_submodule(S[i]):
            # m[i]=1
            m[0, i] = 1
    return m

# Converts the output of parnewmodules to a set of modules.
def tolists(gen, pgendrel, pgendel):
    outrel = []
    outel = []
    for G in gen:
        outrel.append(G[1])
        outel.append(G[0][0][0])
    outrel = block_matrix(len(outrel), 1, outrel)
    if pgendrel != []:
        outrel = block_matrix(2, 1, [pgendrel, outrel])
    outel = pgendel + outel
    return [outrel, outel]

# Splits a list L into a bunch of lists with n elements. Since not all lists have a length divisible by L, the final list may be 
# shorter than len(L)/n.
def split_list(L, n):
    l = (len(L) / n).floor()
    r = len(L) - n * l
    out = []
    for i in range(0, l):
        out.append([L[j] for j in range(i * n, (i + 1) * n)])
    if r > 0:
        out.append([L[j] for j in range(l * n, l * n + r)])
    return out

# Takes two lists L and S with the same entries but in different order and returns a list of integers such that the i'th entry is 
# the index of L[i] in S.
def give_inds(L, S):
    out = []
    for l in L:
        b = l == S[0]
        i = 0
        while b == False:
            i = i + 1
            b = l == S[i]
        out.append(i)
    return out

# Takes a list L and a list of integers inds and returns a list with the same entries as L but with the order specified by inds.
def perm_list(L, inds):
    out = [0 for i in inds]
    for i in range(len(inds)):
        out[inds[i]] = L[i]
    return matrix(out, sparse=True)

def gen_rels(S):
    t0 = walltime()
    rels = []
    els = []
    L = split_list(S, Integer(10 * sage.parallel.ncpus.ncpus()))
    ct = 0
    for l in L:
        # if Mod(ct,8)==0:
        print("The relations of the poset has been " + str(
            (100 * ct / len(L)).n(digits=3)) + "%" + " completed in " + str(walltime() - t0) + " seconds.")
        arg = argtopar_gen_rels(l, S)
        gen = par_gen_rels(arg)
        temp = tolists(gen, rels, els)
        rels = temp[0]
        els = temp[1]
        ct = ct + 1
    inds = give_inds(els, S)
    rels = perm_list(rels, inds)
    print("The relations of the poset were computed in " + str(walltime() - t0) + " seconds.")
    return rels

def add_zero(n):
    if n < 10:
        return str(0) + str(n)
    else:
        return str(n)

def combined_mob(P):
    v = matrix(1, P.dimensions()[0])
    v[0, 0] = 1
    return P.solve_left(v).list()

# -----------------------------------------------------------------------
#
# Code for computing the polynomial.
#
# -----------------------------------------------------------------------

# Takes a matrix g, a root of unity xi and a positive integer n and returns
# a list of powers of g, [g,g^2,...,g^n]
# and a list of powers of xi.
def gpows(g, xi,  n):
    out1 = [g]
    out2 = [xi]
    temp1 = g
    temp2 = xi
    for i in range(n - 1):
        temp1 = temp1 * g
        temp2 = temp2 * xi
        out1.append(temp1)
        out2.append(temp2)
    return [out1,out2]

# Takes a sequence of k numbers (the traces of g acting on V)
# and returns the result of performing Newton-Girard on these nmbers
# (the traces of g acting on wedge 0,1,...,k of V).
def newtongirard(traces):
    trcs = [1] + traces
    k = len(trcs)
    trw = [0] * k
    trw[0] = trcs[0]
    for i in range(k - 1):
        temp = 0
        for j in range(i + 1):
            temp = temp + (-1) ** j * trcs[j + 1] * trw[i - j]
        temp = temp / (i + 1)
        trw[i + 1] = temp
    return trw

def M_trace(g, M):
    out = 0
    for i in range(M.matrix().dimensions()[0]):
        out = out + M.matrix().solve_left(g * M.matrix()[i])[i]
    return out

def M_mult(g, M, Amb):
    Q = Amb / M
    invs = Q.invariants()
    i = 0
    vecs = [vector(M.zero())]
    while i < len(invs) and invs[i] > 1:
        v = Q.gen(i).lift()
        newvecs = []
        for j in range(1, invs[i]):
            for k in range(len(vecs)):
                newvecs.append(vecs[k] + j * v)
        vecs = vecs + newvecs
        i = i + 1
    out = 0
    for v in vecs:
        if Q(v - g * v).is_zero():
            out = out + 1
    return out

def M_polynomial(gpws, xi, Ambtraces, M):
    k = len(Ambtraces) - M.rank()
    Qtraces = []
    for i in range(k):
        Qtraces.append(Ambtraces[i] - M_trace(gpws[i], M))
    wedges = newtongirard(Qtraces)
    t = var("t")
    pol = 0
    for i in range(len(wedges)):
        pol = pol + wedges[i] * t ^ i
    pol = pol.subs(t=xi*t)
    return pol

def torpol(g, xi, R, A, S, mu):
    pol = 0
    Amb = givemodule(R, A)
    d = Amb.rank()
    gpwstot = gpows(g, xi, d)
    gpws = gpwstot[0]
    xipws = gpwstot[1]
    Ambtraces = []
    t = var("t")
    for i in range(len(gpws)):
        Ambtraces.append(M_trace(gpws[i], Amb))
    for i in range(len(S)):
        if mu[i] != 0:
            mult = M_mult(g, S[i], Amb)
            pol = pol + mult * mu[i] * M_polynomial(gpws, xi, Ambtraces, S[i]) * (-t) ** (S[i].rank())
    return expand(pol)

def xi_powers(xi,n):
    out = []
    for i in range(n):
        temp = xi**i
        out.append(temp)
    return out
    
def eis_pols(cls, xis, R, A):
    d = len(cls)*len(xis)
    pols = [1..d]
    for i in range(len(cls)):
        g = cls[i]
        s = stabsubmods(g,R,A)
        S = setofmodules(s)
        P = gen_rels(S)
        mu = combined_mob(P)
        for j in range(len(xis)):
            xi =xis[j]
            pol = torpol(g, xi, R, A, S, mu)
            pols[j*len(cls)+i] = pol
    return pols
